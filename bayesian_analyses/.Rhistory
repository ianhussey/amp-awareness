# plot
plot_model(fit_1,
prob.inner = 0.5,
prob.outer = 0.95)
plot(marginal_effects(fit_1), points = TRUE, ask = FALSE)
# Savage-Dickey Bayes Factor (BF10)
H1_sav_dic         <- fit_1 %>% hypothesis(hypothesis = "influence_rate = 0", alpha = .05)
# p_h1 <- plot(H1_sav_dic, plot = FALSE, theme = theme_get())[[1]]
# p_h1 +
#   xlim(-3, 3) +
#   geom_vline(xintercept = H1_sav_dic$hypothesis$Estimate) +
#   theme_minimal()
plot(H1_sav_dic)
# Posterior evidence ratio (Bayesian p value)
H1_post_evid_ratio <- fit_1 %>% hypothesis(hypothesis = "influence_rate > 0", alpha = .05)
# model specific setup
data          <- exp_2_ia_amp_task_level_data
# weak priors placed on all parameters using reccomendations from  https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations
# use brms default prior for sigma, as it uses a half student t. lower bound (lb) doesn't seem to work for sigma priors; not sure how the default prior manages to be a half t rather than two sided, so use this default.
prior <- c(set_prior(prior = "normal(0, 1)",
class = "Intercept"),
set_prior(prior = "normal(0, 1)",
class = "b"))
# fit model
fit_2_weak_prior <- brm(formula      = model_formula,
family       = model_family,
data         = data,
prior        = prior,
iter         = iterations,
chains       = chains,
sample_prior = sample_prior,
cores        = cores,
control      = control,
file         = model_path)
# check the fit between the posterior distribution and the observed data
pp_check(fit_2_weak_prior, nsamples = 10)
plot(fit_2_weak_prior, ask = FALSE)
# Region of Practical Equivalence set to % of posterior standardized beta values within the range < .1 and > .1. That is, less than small effect size using Cohen's guidelines for R values. If > 95% of posterior is within this range, parameter can be said to be practically zero (i.e., evidence for null effect). Another option is to use Bayes Factors (below). ROPE on the posterior is less sensitive to the prior, but also usually requires greater N to estimate the parameter well enough to make such a conclusion.
ROPE_data <- rope(fit_2_weak_prior, rope = c(-0.1, 0.1)) %>%
dplyr::rename(Parameter = term,
`% inside ROPE` = rope) %>%
filter(grepl("b_", Parameter) & !grepl("prior", Parameter)) %>%
mutate(Parameter = str_replace_all(Parameter, "b_", ""),
Parameter = str_replace_all(Parameter, "[.]", ":"))
results_data <- summary(fit_2_weak_prior)$fixed %>%
as.data.frame() %>%
rownames_to_column(var = "Parameter") %>%
dplyr::rename(SE = Est.Error,
Lower = `l-95% CI`,
Upper = `u-95% CI`) %>%
full_join(ROPE_data, by = "Parameter") %>%
round_df(2)
# table
results_data %>%
dplyr::select(Parameter, Estimate, SE, Lower, Upper, `% inside ROPE`, Eff.Sample, Rhat) %>%
dplyr::rename(`Std. Beta` = Estimate) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
add_header_above(c(" " = 3, "95% CI" = 2, " " = 3))
# plot
plot_model(fit_2_weak_prior,
prob.inner = 0.5,
prob.outer = 0.95)
plot(marginal_effects(fit_2_weak_prior), points = TRUE, ask = FALSE)
# Savage-Dickey Bayes Factor (BF10)
H2_weak_sav_dic         <- fit_2_weak_prior %>% hypothesis(hypothesis = "influence_rate = 0", alpha = .05)
# p_h2_weak <- plot(H2_weak_sav_dic, plot = FALSE, theme = theme_get())[[1]]
# p_h2_weak +
#   xlim(-3, 3) +
#   geom_vline(xintercept = H2_sav_dic$hypothesis$Estimate) +
#   theme_minimal()
plot(H2_weak_sav_dic)
# Posterior evidence ratio (Bayesian p value)
H2_weak_post_evid_ratio <- fit_2_weak_prior %>% hypothesis(hypothesis = "influence_rate > 0", alpha = .05)
fit_1_posterior <- as.data.frame(fit_1)
# ggplot(fit_1_posterior, aes(b_influence_rate)) +
#   geom_density()
# mean and sd of posterior of b_influence_rate
fit_1_posterior %>%
summarize(mean = mean(b_influence_rate),
sd = sd(b_influence_rate)) %>%
round_df(2)
# plot posterior vs parameterisation of it.
## nb range may have to be manually adjusted for stat_function
# b_Intercept
ggplot() +
geom_density(data = fit_1_posterior,
aes(b_Intercept, color = "posterior")) +
stat_function(data = data.frame(x = c(0, 0.3)),
aes(x, color = "parameterised"),
fun = dnorm,
n = 101,
args = list(mean = mean(fit_1_posterior$b_Intercept),
sd = sd(fit_1_posterior$b_Intercept)),
linetype = "dashed") +
scale_colour_viridis_d(begin = 0.3, end = 0.8, direction = -1)
# b_influence_rate
ggplot() +
geom_density(data = fit_1_posterior,
aes(b_influence_rate, color = "posterior")) +
stat_function(data = data.frame(x = c(0.1, 0.6)),
aes(x, color = "parameterised"),
fun = dnorm,
n = 101,
args = list(mean = mean(fit_1_posterior$b_influence_rate),
sd = sd(fit_1_posterior$b_influence_rate)),
linetype = "dashed") +
scale_colour_viridis_d(begin = 0.3, end = 0.8, direction = -1)
# sigma
ggplot() +
geom_density(data = fit_1_posterior,
aes(sigma, color = "posterior")) +
stat_function(data = data.frame(x = c(0.1, 0.3)),
aes(x, color = "parameterised"),
fun = dnorm,
n = 101,
args = list(mean = mean(fit_1_posterior$sigma),
sd = sd(fit_1_posterior$sigma)),
linetype = "dashed") +
scale_colour_viridis_d(begin = 0.3, end = 0.8, direction = -1)
# # check what parameteris require priors
# get_prior(formula = model_formula,
#           family  = model_family,
#           data    = data)
# model specific setup
data          <- exp_2_ia_amp_task_level_data
prior <- c(set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_Intercept),
", ",
sd(fit_1_posterior$b_Intercept),
")"),
class = "Intercept"),
set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_influence_rate),
", ",
sd(fit_1_posterior$b_influence_rate),
")"),
class = "b"),
set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_influence_rate),
", ",
sd(fit_1_posterior$b_influence_rate),
")"),
class = "sigma"))
model_path    <- "models/IA-AMP moderated by influence/fit_2_informed_prior"
# fit model
fit_2 <- brm(formula      = model_formula,
family       = model_family,
data         = data,
prior        = prior,
iter         = iterations,
chains       = chains,
sample_prior = sample_prior,
cores        = cores,
control      = control,
file         = model_path)
# # check what parameteris require priors
# get_prior(formula = model_formula,
#           family  = model_family,
#           data    = data)
# model specific setup
data          <- exp_2_ia_amp_task_level_data
prior <- c(set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_Intercept),
", ",
sd(fit_1_posterior$b_Intercept),
")"),
class = "Intercept"),
set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_influence_rate),
", ",
sd(fit_1_posterior$b_influence_rate),
")"),
class = "b"),
set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_influence_rate),
", ",
sd(fit_1_posterior$b_influence_rate),
")"),
class = "sigma"))
model_path    <- "models/IA-AMP moderated by influence/fit_2_informed_prior"
# fit model
fit_2 <- brm(formula      = model_formula,
family       = model_family,
data         = data,
prior        = prior,
iter         = iterations,
chains       = chains,
sample_prior = sample_prior,
cores        = cores,
control      = control,
file         = model_path)
knitr::opts_chunk$set(echo = FALSE,
message = FALSE,
warning = FALSE)
# set seed
set.seed(42)
# disable scientific notation
options(scipen = 999)
# options
options(knitr.table.format = "html")  # comment out if knitting to pdf
# dependencies
library(tidyverse)
library(knitr)
library(kableExtra)
library(plotrix)  # for std.error
library(brms)
library(parallel)
library(sjPlot)
library(sjstats)
library(patchwork)
# rounds all numerics in a df
round_df <- function(df, digits) {
nums <- vapply(df, is.numeric, FUN.VALUE = logical(1))
df[,nums] <- round(df[,nums], digits = digits)
(df)
}
# get data
exp_1_ia_amp_task_level_data  <- read.csv("../experiment 1/data/processed/processed_data.csv") %>%
mutate(absolute_int_amp_effect = abs(IA_AMP_effect_positive_negative),
absolute_int_amp_effect_standaridized = round(as.numeric(scale(absolute_int_amp_effect)), 3),
Experiment = 1) %>%
filter(self_exclusion_1 == "Yes, use my data" & complete_data == TRUE) %>%
select(Experiment, subject, age, gender, absolute_int_amp_effect, absolute_int_amp_effect_standaridized, influence_rate)
exp_2_ia_amp_task_level_data  <- read.csv("../experiment 2/data/processed/processed_data.csv") %>%
mutate(absolute_int_amp_effect = abs(IA_AMP_effect_positive_negative),
absolute_int_amp_effect_standaridized = round(as.numeric(scale(absolute_int_amp_effect)), 3),
Experiment = 2) %>%
filter(self_exclusion_1 == "Yes, use my data" & complete_data == TRUE) %>%
select(Experiment, subject, age, gender, absolute_int_amp_effect, absolute_int_amp_effect_standaridized, influence_rate)
exp_3_ia_amp_task_level_data  <- read.csv("../experiment 3/data/processed/processed_data.csv") %>%
mutate(absolute_int_amp_effect = abs(IA_AMP_effect_positive_negative),
absolute_int_amp_effect_standaridized = round(as.numeric(scale(absolute_int_amp_effect)), 3),
Experiment = 3) %>%
filter(self_exclusion_1 == "Yes, use my data" & complete_data == TRUE) %>%
select(Experiment, subject, age, gender, absolute_int_amp_effect, absolute_int_amp_effect_standaridized, influence_rate)
exp_4_ia_amp_task_level_data  <- read.csv("../experiment 4/data/processed/processed_data.csv") %>%
mutate(absolute_int_amp_effect = abs(IA_AMP_effect_positive_negative),
absolute_int_amp_effect_standaridized = round(as.numeric(scale(absolute_int_amp_effect)), 3),
Experiment = 4,
influence_rate = influence_rate_positive_negative) %>%
filter(self_exclusion_1 == "Yes, use my data" & complete_data == TRUE) %>%
select(Experiment, subject, age, gender, absolute_int_amp_effect, absolute_int_amp_effect_standaridized, influence_rate)
# combined
combined_data <- rbind(exp_1_ia_amp_task_level_data,
exp_2_ia_amp_task_level_data,
exp_3_ia_amp_task_level_data,
exp_4_ia_amp_task_level_data) %>%
mutate(Experiment = as.factor(Experiment))
# plot
ggplot(combined_data, aes(influence_rate,
absolute_int_amp_effect,
color = Experiment,
group = Experiment)) +
geom_jitter(alpha = 0.2) +
geom_rug(position = "jitter", alpha = 0.2) +
geom_smooth(method = lm) +
labs(x = "Proportion of influenced trials",
y = "Absolute AMP effect") +
theme_classic() +
ylim(0, 1) +
scale_colour_viridis_d(end = 0.8) +
scale_fill_viridis_d(end = 0.8)
# model generic setup
iterations    <- 2000
chains        <- 4
sample_prior  <- TRUE  # to optionally calculate Savage Dickey-BF
cores         <- detectCores()
control       <- list(adapt_delta = 0.99)
model_formula <- absolute_int_amp_effect ~ influence_rate
model_family  <- gaussian(link = "identity")
# model specific setup
data          <- exp_1_ia_amp_task_level_data
# # check what parameteris require priors
# get_prior(formula = model_formula,
#           family  = model_family,
#           data    = data)
# weak priors placed on all parameters using reccomendations from  https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations
# use brms default prior for sigma, as it uses a half student t. lower bound (lb) doesn't seem to work for sigma priors; not sure how the default prior manages to be a half t rather than two sided, so use this default.
prior <- c(set_prior(prior = "normal(0, 1)",
class = "Intercept"),
set_prior(prior = "normal(0, 1)",
class = "b"))
model_path    <- "models/IA-AMP moderated by influence/fit_1_weak_prior"
# fit model
fit_1 <- brm(formula      = model_formula,
family       = model_family,
data         = data,
prior        = prior,
iter         = iterations,
chains       = chains,
sample_prior = sample_prior,
cores        = cores,
control      = control,
file         = model_path)
# model specific setup
data          <- exp_2_ia_amp_task_level_data
# weak priors placed on all parameters using reccomendations from  https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations
# use brms default prior for sigma, as it uses a half student t. lower bound (lb) doesn't seem to work for sigma priors; not sure how the default prior manages to be a half t rather than two sided, so use this default.
prior <- c(set_prior(prior = "normal(0, 1)",
class = "Intercept"),
set_prior(prior = "normal(0, 1)",
class = "b"))
# fit model
fit_2_weak_prior <- brm(formula      = model_formula,
family       = model_family,
data         = data,
prior        = prior,
iter         = iterations,
chains       = chains,
sample_prior = sample_prior,
cores        = cores,
control      = control,
file         = model_path)
# # check what parameteris require priors
# get_prior(formula = model_formula,
#           family  = model_family,
#           data    = data)
# model specific setup
data          <- exp_2_ia_amp_task_level_data
prior <- c(set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_Intercept),
", ",
sd(fit_1_posterior$b_Intercept),
")"),
class = "Intercept"),
set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_influence_rate),
", ",
sd(fit_1_posterior$b_influence_rate),
")"),
class = "b"),
set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_influence_rate),
", ",
sd(fit_1_posterior$b_influence_rate),
")"),
class = "sigma"))
# Region of Practical Equivalence set to % of posterior standardized beta values within the range < .1 and > .1. That is, less than small effect size using Cohen's guidelines for R values. If > 95% of posterior is within this range, parameter can be said to be practically zero (i.e., evidence for null effect). Another option is to use Bayes Factors (below). ROPE on the posterior is less sensitive to the prior, but also usually requires greater N to estimate the parameter well enough to make such a conclusion.
ROPE_data <- rope(fit_2_weak_prior, rope = c(-0.1, 0.1)) %>%
dplyr::rename(Parameter = term,
`% inside ROPE` = rope) %>%
filter(grepl("b_", Parameter) & !grepl("prior", Parameter)) %>%
mutate(Parameter = str_replace_all(Parameter, "b_", ""),
Parameter = str_replace_all(Parameter, "[.]", ":"))
results_data <- summary(fit_2_weak_prior)$fixed %>%
as.data.frame() %>%
rownames_to_column(var = "Parameter") %>%
dplyr::rename(SE = Est.Error,
Lower = `l-95% CI`,
Upper = `u-95% CI`) %>%
full_join(ROPE_data, by = "Parameter") %>%
round_df(2)
# table
results_data %>%
dplyr::select(Parameter, Estimate, SE, Lower, Upper, `% inside ROPE`, Eff.Sample, Rhat) %>%
dplyr::rename(`Std. Beta` = Estimate) %>%
kable() %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE) %>%
add_header_above(c(" " = 3, "95% CI" = 2, " " = 3))
# plot
plot_model(fit_2_weak_prior,
prob.inner = 0.5,
prob.outer = 0.95)
plot(marginal_effects(fit_2_weak_prior), points = TRUE, ask = FALSE)
# Savage-Dickey Bayes Factor (BF10)
H2_weak_sav_dic         <- fit_2_weak_prior %>% hypothesis(hypothesis = "influence_rate = 0", alpha = .05)
# p_h2_weak <- plot(H2_weak_sav_dic, plot = FALSE, theme = theme_get())[[1]]
# p_h2_weak +
#   xlim(-3, 3) +
#   geom_vline(xintercept = H2_sav_dic$hypothesis$Estimate) +
#   theme_minimal()
plot(H2_weak_sav_dic)
# Posterior evidence ratio (Bayesian p value)
H2_weak_post_evid_ratio <- fit_2_weak_prior %>% hypothesis(hypothesis = "influence_rate > 0", alpha = .05)
fit_1_posterior <- as.data.frame(fit_1)
# ggplot(fit_1_posterior, aes(b_influence_rate)) +
#   geom_density()
# mean and sd of posterior of b_influence_rate
fit_1_posterior %>%
summarize(mean = mean(b_influence_rate),
sd = sd(b_influence_rate)) %>%
round_df(2)
# plot posterior vs parameterisation of it.
## nb range may have to be manually adjusted for stat_function
# b_Intercept
ggplot() +
geom_density(data = fit_1_posterior,
aes(b_Intercept, color = "posterior")) +
stat_function(data = data.frame(x = c(0, 0.3)),
aes(x, color = "parameterised"),
fun = dnorm,
n = 101,
args = list(mean = mean(fit_1_posterior$b_Intercept),
sd = sd(fit_1_posterior$b_Intercept)),
linetype = "dashed") +
scale_colour_viridis_d(begin = 0.3, end = 0.8, direction = -1)
# b_influence_rate
ggplot() +
geom_density(data = fit_1_posterior,
aes(b_influence_rate, color = "posterior")) +
stat_function(data = data.frame(x = c(0.1, 0.6)),
aes(x, color = "parameterised"),
fun = dnorm,
n = 101,
args = list(mean = mean(fit_1_posterior$b_influence_rate),
sd = sd(fit_1_posterior$b_influence_rate)),
linetype = "dashed") +
scale_colour_viridis_d(begin = 0.3, end = 0.8, direction = -1)
# sigma
ggplot() +
geom_density(data = fit_1_posterior,
aes(sigma, color = "posterior")) +
stat_function(data = data.frame(x = c(0.1, 0.3)),
aes(x, color = "parameterised"),
fun = dnorm,
n = 101,
args = list(mean = mean(fit_1_posterior$sigma),
sd = sd(fit_1_posterior$sigma)),
linetype = "dashed") +
scale_colour_viridis_d(begin = 0.3, end = 0.8, direction = -1)
# # check what parameteris require priors
# get_prior(formula = model_formula,
#           family  = model_family,
#           data    = data)
# model specific setup
data          <- exp_2_ia_amp_task_level_data
prior <- c(set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_Intercept),
", ",
sd(fit_1_posterior$b_Intercept),
")"),
class = "Intercept"),
set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_influence_rate),
", ",
sd(fit_1_posterior$b_influence_rate),
")"),
class = "b"),
set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_influence_rate),
", ",
sd(fit_1_posterior$b_influence_rate),
")"),
class = "sigma"))
model_path    <- "models/IA-AMP moderated by influence/fit_2_informed_prior"
# fit model
fit_2 <- brm(formula      = model_formula,
family       = model_family,
data         = data,
prior        = prior,
iter         = iterations,
chains       = chains,
sample_prior = sample_prior,
cores        = cores,
control      = control,
file         = model_path)
prior <- c(set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_Intercept),
", ",
sd(fit_1_posterior$b_Intercept),
")"),
class = "Intercept"),
set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_influence_rate),
", ",
sd(fit_1_posterior$b_influence_rate),
")"),
class = "b"),
set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_influence_rate),
", ",
sd(fit_1_posterior$b_influence_rate),
")"),
class = "sigma"))
prior
# # check what parameteris require priors
# get_prior(formula = model_formula,
#           family  = model_family,
#           data    = data)
# model specific setup
data          <- exp_2_ia_amp_task_level_data
prior <- c(set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_Intercept),
", ",
sd(fit_1_posterior$b_Intercept),
")"),
class = "Intercept"),
set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_influence_rate),
", ",
sd(fit_1_posterior$b_influence_rate),
")"),
class = "b"),
set_prior(prior = paste0("normal(",
mean(fit_1_posterior$b_sigma),
", ",
sd(fit_1_posterior$b_sigma),
")"),
class = "sigma"))
model_path    <- "models/IA-AMP moderated by influence/fit_2_informed_prior"
# fit model
fit_2 <- brm(formula      = model_formula,
family       = model_family,
data         = data,
prior        = prior,
iter         = iterations,
chains       = chains,
sample_prior = sample_prior,
cores        = cores,
control      = control,
file         = model_path)
