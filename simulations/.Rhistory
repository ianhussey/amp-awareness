for (i in 1:ny) {
jk[nx + i] <- ruscios_A(x, y[-i])
}
Diff <- mean(jk) - jk
a <- sum(Diff ^ 3) / (6 * (sum(Diff ^ 2)) ^ 1.5)
# adjust location of endpoints
Alpha1 <- pnorm(z0 + (z0 + qnorm(Alpha/2)) / (1 - a * (z0 + qnorm(Alpha/2))))
Alpha2 <- pnorm(z0 + (z0 - qnorm(Alpha/2)) / (1 - a * (z0 - qnorm(Alpha/2))))
# if either endpoint undefined, replace it with value for percentile CI
if (is.na(Alpha1)) {Alpha1 <- Alpha / 2}
if (is.na(Alpha2)) {Alpha2 <- 1 - Alpha / 2}
if (round(Alpha1 * B) < 1) {CI.Lower <- BS.Values[1]}
else {
CI.Lower <- BS.Values[round(Alpha1 * B)]
CI.Upper <- BS.Values[round(Alpha2 * B)]
}
}
# return A, SE of A, lower limit of CI, upper limit of CI
results <- data.frame(rucsios_A        = round(A.obs,         3),
rucsios_A_se     = round(sd(BS.Values), 3),
rucsios_A_ci_lwr = round(CI.Lower,      3),
rucsios_A_ci_upr = round(CI.Upper,      3))
return(results)
}
sced_results <- sced_analysis(data = simulated_data)
results <- sced_results
# get data
data_for_meta_analysis <- results %>%
mutate(
yi = ruscios_A,
# convert SE to variance
vi = ruscios_A_se^2
)
ruscios_A_boot <- function(data, variable, group, value1 = 1, value2 = 0,
B = 2000, Conf.Level = .95, seed = 1) {
# Fast calculation of the A statistic
ruscios_A <- function(x, y) {
nx <- length(x)
ny <- length(y)
rx <- sum(rank(c(x, y))[1:nx])
A = (rx / nx - (nx + 1) / 2) / ny
return(A)
}
# Ensure data is a data frame (e.g., not a tbl_data)
data <- as.data.frame(data)
# Select the observations for group 1
x <- data[data[[group]] == value1, variable]
# Select the observations for group 2
y <- data[data[[group]] == value2, variable]
# initialize variables
set.seed(seed)
nx <- length(x)
ny <- length(y)
A.obs <- ruscios_A(x, y)
Alpha <- 1 - Conf.Level
CI.Lower <- CI.Upper <- pi
# perform bootstrap to generate B values of A
BS.Values <- rep(0, B)
for (i in 1:B) {
BS.Values[i] <- ruscios_A(sample(x, replace = T), sample(y, replace = TRUE))
}
BS.Values <- sort(BS.Values)
# if all bootstrap samples yield same value for A, use it for both ends of CI
if (min(BS.Values) == max(BS.Values)) {
CI.Lower <- CI.Upper <- BS.Values[1]
}
# if sample value not within range of bootstrap values, revert to percentile CI
if ((A.obs < min(BS.Values)) | (A.obs > max(BS.Values))) {
CI.Lower <- BS.Values[round((Alpha / 2) * B)]
CI.Upper <- BS.Values[round((1 - Alpha / 2) * B)]
}
# otherwise, use BCA CI
if ((CI.Lower == pi) & (CI.Upper == pi)) {
# calculate bias-correction and acceleration parameters (z0 and a)
z0 <- qnorm(mean(BS.Values < A.obs))
jk <- rep(0, (nx + ny))
for (i in 1:nx) {
jk[i] <- ruscios_A(x[-i], y)
}
for (i in 1:ny) {
jk[nx + i] <- ruscios_A(x, y[-i])
}
Diff <- mean(jk) - jk
a <- sum(Diff ^ 3) / (6 * (sum(Diff ^ 2)) ^ 1.5)
# adjust location of endpoints
Alpha1 <- pnorm(z0 + (z0 + qnorm(Alpha/2)) / (1 - a * (z0 + qnorm(Alpha/2))))
Alpha2 <- pnorm(z0 + (z0 - qnorm(Alpha/2)) / (1 - a * (z0 - qnorm(Alpha/2))))
# if either endpoint undefined, replace it with value for percentile CI
if (is.na(Alpha1)) {Alpha1 <- Alpha / 2}
if (is.na(Alpha2)) {Alpha2 <- 1 - Alpha / 2}
if (round(Alpha1 * B) < 1) {CI.Lower <- BS.Values[1]}
else {
CI.Lower <- BS.Values[round(Alpha1 * B)]
CI.Upper <- BS.Values[round(Alpha2 * B)]
}
}
# return A, SE of A, lower limit of CI, upper limit of CI
results <- data.frame(rucsios_A_estimate = round(A.obs,         3),
rucsios_A_se       = round(sd(BS.Values), 3),
rucsios_A_ci_lwr   = round(CI.Lower,      3),
rucsios_A_ci_upr   = round(CI.Upper,      3))
return(results)
}
ruscios_A_boot <- function(data, variable, group, value1 = 1, value2 = 0,
B = 2000, Conf.Level = .95, seed = 1) {
# Fast calculation of the A statistic
ruscios_A <- function(x, y) {
nx <- length(x)
ny <- length(y)
rx <- sum(rank(c(x, y))[1:nx])
A = (rx / nx - (nx + 1) / 2) / ny
return(A)
}
# Ensure data is a data frame (e.g., not a tbl_data)
data <- as.data.frame(data)
# Select the observations for group 1
x <- data[data[[group]] == value1, variable]
# Select the observations for group 2
y <- data[data[[group]] == value2, variable]
# initialize variables
set.seed(seed)
nx <- length(x)
ny <- length(y)
A.obs <- ruscios_A(x, y)
Alpha <- 1 - Conf.Level
CI.Lower <- CI.Upper <- pi
# perform bootstrap to generate B values of A
BS.Values <- rep(0, B)
for (i in 1:B) {
BS.Values[i] <- ruscios_A(sample(x, replace = T), sample(y, replace = TRUE))
}
BS.Values <- sort(BS.Values)
# if all bootstrap samples yield same value for A, use it for both ends of CI
if (min(BS.Values) == max(BS.Values)) {
CI.Lower <- CI.Upper <- BS.Values[1]
}
# if sample value not within range of bootstrap values, revert to percentile CI
if ((A.obs < min(BS.Values)) | (A.obs > max(BS.Values))) {
CI.Lower <- BS.Values[round((Alpha / 2) * B)]
CI.Upper <- BS.Values[round((1 - Alpha / 2) * B)]
}
# otherwise, use BCA CI
if ((CI.Lower == pi) & (CI.Upper == pi)) {
# calculate bias-correction and acceleration parameters (z0 and a)
z0 <- qnorm(mean(BS.Values < A.obs))
jk <- rep(0, (nx + ny))
for (i in 1:nx) {
jk[i] <- ruscios_A(x[-i], y)
}
for (i in 1:ny) {
jk[nx + i] <- ruscios_A(x, y[-i])
}
Diff <- mean(jk) - jk
a <- sum(Diff ^ 3) / (6 * (sum(Diff ^ 2)) ^ 1.5)
# adjust location of endpoints
Alpha1 <- pnorm(z0 + (z0 + qnorm(Alpha/2)) / (1 - a * (z0 + qnorm(Alpha/2))))
Alpha2 <- pnorm(z0 + (z0 - qnorm(Alpha/2)) / (1 - a * (z0 - qnorm(Alpha/2))))
# if either endpoint undefined, replace it with value for percentile CI
if (is.na(Alpha1)) {Alpha1 <- Alpha / 2}
if (is.na(Alpha2)) {Alpha2 <- 1 - Alpha / 2}
if (round(Alpha1 * B) < 1) {CI.Lower <- BS.Values[1]}
else {
CI.Lower <- BS.Values[round(Alpha1 * B)]
CI.Upper <- BS.Values[round(Alpha2 * B)]
}
}
# return A, SE of A, lower limit of CI, upper limit of CI
results <- data.frame(rucsios_A_estimate = round(A.obs,         3),
rucsios_A_se       = round(sd(BS.Values), 3),
rucsios_A_ci_lwr   = round(CI.Lower,      3),
rucsios_A_ci_upr   = round(CI.Upper,      3))
return(results)
}
ruscios_A_boot <- function(data, variable, group, value1 = 1, value2 = 0,
B = 2000, Conf.Level = .95, seed = 1) {
# Fast calculation of the A statistic
ruscios_A_function <- function(x, y) {
nx <- length(x)
ny <- length(y)
rx <- sum(rank(c(x, y))[1:nx])
A = (rx / nx - (nx + 1) / 2) / ny
return(A)
}
# Ensure data is a data frame (e.g., not a tbl_data)
data <- as.data.frame(data)
# Select the observations for group 1
x <- data[data[[group]] == value1, variable]
# Select the observations for group 2
y <- data[data[[group]] == value2, variable]
# initialize variables
set.seed(seed)
nx <- length(x)
ny <- length(y)
A.obs <- ruscios_A(x, y)
Alpha <- 1 - Conf.Level
CI.Lower <- CI.Upper <- pi
# perform bootstrap to generate B values of A
BS.Values <- rep(0, B)
for (i in 1:B) {
BS.Values[i] <- ruscios_A(sample(x, replace = T), sample(y, replace = TRUE))
}
BS.Values <- sort(BS.Values)
# if all bootstrap samples yield same value for A, use it for both ends of CI
if (min(BS.Values) == max(BS.Values)) {
CI.Lower <- CI.Upper <- BS.Values[1]
}
# if sample value not within range of bootstrap values, revert to percentile CI
if ((A.obs < min(BS.Values)) | (A.obs > max(BS.Values))) {
CI.Lower <- BS.Values[round((Alpha / 2) * B)]
CI.Upper <- BS.Values[round((1 - Alpha / 2) * B)]
}
# otherwise, use BCA CI
if ((CI.Lower == pi) & (CI.Upper == pi)) {
# calculate bias-correction and acceleration parameters (z0 and a)
z0 <- qnorm(mean(BS.Values < A.obs))
jk <- rep(0, (nx + ny))
for (i in 1:nx) {
jk[i] <- ruscios_A(x[-i], y)
}
for (i in 1:ny) {
jk[nx + i] <- ruscios_A(x, y[-i])
}
Diff <- mean(jk) - jk
a <- sum(Diff ^ 3) / (6 * (sum(Diff ^ 2)) ^ 1.5)
# adjust location of endpoints
Alpha1 <- pnorm(z0 + (z0 + qnorm(Alpha/2)) / (1 - a * (z0 + qnorm(Alpha/2))))
Alpha2 <- pnorm(z0 + (z0 - qnorm(Alpha/2)) / (1 - a * (z0 - qnorm(Alpha/2))))
# if either endpoint undefined, replace it with value for percentile CI
if (is.na(Alpha1)) {Alpha1 <- Alpha / 2}
if (is.na(Alpha2)) {Alpha2 <- 1 - Alpha / 2}
if (round(Alpha1 * B) < 1) {CI.Lower <- BS.Values[1]}
else {
CI.Lower <- BS.Values[round(Alpha1 * B)]
CI.Upper <- BS.Values[round(Alpha2 * B)]
}
}
# return A, SE of A, lower limit of CI, upper limit of CI
results <- data.frame(rucsios_A        = round(A.obs,         3),
rucsios_A_se     = round(sd(BS.Values), 3),
rucsios_A_ci_lwr = round(CI.Lower,      3),
rucsios_A_ci_upr = round(CI.Upper,      3))
return(results)
}
ruscios_A_boot <- function(data, variable, group, value1 = 1, value2 = 0,
B = 2000, Conf.Level = .95, seed = 1) {
# Fast calculation of the A statistic
ruscios_A_function <- function(x, y) {
nx <- length(x)
ny <- length(y)
rx <- sum(rank(c(x, y))[1:nx])
A = (rx / nx - (nx + 1) / 2) / ny
return(A)
}
# Ensure data is a data frame (e.g., not a tbl_data)
data <- as.data.frame(data)
# Select the observations for group 1
x <- data[data[[group]] == value1, variable]
# Select the observations for group 2
y <- data[data[[group]] == value2, variable]
# initialize variables
set.seed(seed)
nx <- length(x)
ny <- length(y)
A.obs <- ruscios_A_function(x, y)
Alpha <- 1 - Conf.Level
CI.Lower <- CI.Upper <- pi
# perform bootstrap to generate B values of A
BS.Values <- rep(0, B)
for (i in 1:B) {
BS.Values[i] <- ruscios_A_function(sample(x, replace = T), sample(y, replace = TRUE))
}
BS.Values <- sort(BS.Values)
# if all bootstrap samples yield same value for A, use it for both ends of CI
if (min(BS.Values) == max(BS.Values)) {
CI.Lower <- CI.Upper <- BS.Values[1]
}
# if sample value not within range of bootstrap values, revert to percentile CI
if ((A.obs < min(BS.Values)) | (A.obs > max(BS.Values))) {
CI.Lower <- BS.Values[round((Alpha / 2) * B)]
CI.Upper <- BS.Values[round((1 - Alpha / 2) * B)]
}
# otherwise, use BCA CI
if ((CI.Lower == pi) & (CI.Upper == pi)) {
# calculate bias-correction and acceleration parameters (z0 and a)
z0 <- qnorm(mean(BS.Values < A.obs))
jk <- rep(0, (nx + ny))
for (i in 1:nx) {
jk[i] <- ruscios_A_function(x[-i], y)
}
for (i in 1:ny) {
jk[nx + i] <- ruscios_A_function(x, y[-i])
}
Diff <- mean(jk) - jk
a <- sum(Diff ^ 3) / (6 * (sum(Diff ^ 2)) ^ 1.5)
# adjust location of endpoints
Alpha1 <- pnorm(z0 + (z0 + qnorm(Alpha/2)) / (1 - a * (z0 + qnorm(Alpha/2))))
Alpha2 <- pnorm(z0 + (z0 - qnorm(Alpha/2)) / (1 - a * (z0 - qnorm(Alpha/2))))
# if either endpoint undefined, replace it with value for percentile CI
if (is.na(Alpha1)) {Alpha1 <- Alpha / 2}
if (is.na(Alpha2)) {Alpha2 <- 1 - Alpha / 2}
if (round(Alpha1 * B) < 1) {CI.Lower <- BS.Values[1]}
else {
CI.Lower <- BS.Values[round(Alpha1 * B)]
CI.Upper <- BS.Values[round(Alpha2 * B)]
}
}
# return A, SE of A, lower limit of CI, upper limit of CI
results <- data.frame(rucsios_A        = round(A.obs,         3),
rucsios_A_se     = round(sd(BS.Values), 3),
rucsios_A_ci_lwr = round(CI.Lower,      3),
rucsios_A_ci_upr = round(CI.Upper,      3))
return(results)
}
sced_analysis <- function(data, n_boots = 10000) {
require(tidyverse)
require(coin)
require(effsize)
require(bootES)
data(simulated_data)
# p values via non-parametric permutation tests
p_by_participant <- data %>%
dplyr::group_by(Participant) %>%
do(p = pvalue(independence_test(Score ~ as.factor(Condition),
distribution = approximate(B = n_boots),
data = .))) %>%
ungroup() %>%
dplyr::mutate(p = as.numeric(p),
p = ifelse(p < .00001, "< .00001", round(p, 5)))
median_change <- data %>%
group_by(Participant) %>%
dplyr::summarize(median_a = median(Score[Condition == "A"]),
median_b = median(Score[Condition == "B"]),
median_difference = median_b - median_a,
na.rm = TRUE) %>%
dplyr::select(Participant, median_difference)
# bootstrapped Ruscio's nonparametric effect size A
# function defined elsewhere in this package
ruscios_A_boot_by_participant <- data %>%
group_by(Participant) %>%
do(ruscios_A_boot(variable = "Score",
group = "Condition",
data = .,
value1 = "A",
value2 = "B",
B = n_boots)) %>%
ungroup()
# bootstrapped Hedges' g effect size (removes assumption of normality but not equality of variances or equal N per condition)
hedges_g_boot <- function(data) {
require(bootES)
require(tidyverse)
fit <- data %>%
bootES(.,
R = n_boots,
data.col = "Score",
group.col = "Condition",
contrast = c(A = -1, B = 1),
effect.type = "hedges.g",
ci.type = "bca",
ci.conf = 0.95)
results <- data.frame(hedges_g        = round(fit$t0,        3),
hedges_g_se     = round(sd(fit$t),     3),
hedges_g_ci_lwr = round(fit$bounds[1], 3),
hedges_g_ci_upr = round(fit$bounds[2], 3))
}
hedges_g_by_participant <- data %>%
group_by(Participant) %>%
do(hedges_g_boot(data = .)) %>%
ungroup()
# combine results
results <- p_by_participant %>%
left_join(median_change, by = "Participant") %>%
left_join(ruscios_A_boot_by_participant, by = "Participant") %>%
left_join(hedges_g_by_participant, by = "Participant")
return(results)
}
sced_analysis <- function(data, n_boots = 2000) {
require(tidyverse)
require(coin)
require(effsize)
require(bootES)
data(simulated_data)
# p values via non-parametric permutation tests
p_by_participant <- data %>%
dplyr::group_by(Participant) %>%
do(p = pvalue(independence_test(Score ~ as.factor(Condition),
distribution = approximate(B = n_boots),
data = .))) %>%
ungroup() %>%
dplyr::mutate(p = as.numeric(p),
p = ifelse(p < .00001, "< .00001", round(p, 5)))
median_change <- data %>%
group_by(Participant) %>%
dplyr::summarize(median_a = median(Score[Condition == "A"]),
median_b = median(Score[Condition == "B"]),
median_difference = median_b - median_a,
na.rm = TRUE) %>%
dplyr::select(Participant, median_difference)
# bootstrapped Ruscio's nonparametric effect size A
# function defined elsewhere in this package
ruscios_A_boot_by_participant <- data %>%
group_by(Participant) %>%
do(ruscios_A_boot(variable = "Score",
group = "Condition",
data = .,
value1 = "A",
value2 = "B",
B = n_boots)) %>%
ungroup()
# bootstrapped Hedges' g effect size (removes assumption of normality but not equality of variances or equal N per condition)
hedges_g_boot <- function(data) {
require(bootES)
require(tidyverse)
fit <- data %>%
bootES(.,
R = n_boots,
data.col = "Score",
group.col = "Condition",
contrast = c(A = -1, B = 1),
effect.type = "hedges.g",
ci.type = "bca",
ci.conf = 0.95)
results <- data.frame(hedges_g        = round(fit$t0,        3),
hedges_g_se     = round(sd(fit$t),     3),
hedges_g_ci_lwr = round(fit$bounds[1], 3),
hedges_g_ci_upr = round(fit$bounds[2], 3))
}
hedges_g_by_participant <- data %>%
group_by(Participant) %>%
do(hedges_g_boot(data = .)) %>%
ungroup()
# combine results
results <- p_by_participant %>%
left_join(median_change, by = "Participant") %>%
left_join(ruscios_A_boot_by_participant, by = "Participant") %>%
left_join(hedges_g_by_participant, by = "Participant")
return(results)
}
sced_analysis <- function(data, n_boots = 2000) {
require(tidyverse)
require(coin)
require(effsize)
require(bootES)
data(simulated_data)
# p values via non-parametric permutation tests
p_by_participant <- data %>%
dplyr::group_by(Participant) %>%
do(p = pvalue(independence_test(Score ~ as.factor(Condition),
distribution = approximate(B = n_boots*10), # needs more than other tests
data = .))) %>%
ungroup() %>%
dplyr::mutate(p = as.numeric(p),
p = ifelse(p < .00001, "< .00001", round(p, 5)))
median_change <- data %>%
group_by(Participant) %>%
dplyr::summarize(median_a = median(Score[Condition == "A"]),
median_b = median(Score[Condition == "B"]),
median_difference = median_b - median_a,
na.rm = TRUE) %>%
dplyr::select(Participant, median_difference)
# bootstrapped Ruscio's nonparametric effect size A
# function defined elsewhere in this package
ruscios_A_boot_by_participant <- data %>%
group_by(Participant) %>%
do(ruscios_A_boot(variable = "Score",
group = "Condition",
data = .,
value1 = "A",
value2 = "B",
B = n_boots)) %>%
ungroup()
# bootstrapped Hedges' g effect size (removes assumption of normality but not equality of variances or equal N per condition)
hedges_g_boot <- function(data) {
require(bootES)
require(tidyverse)
fit <- data %>%
bootES(.,
R = n_boots,
data.col = "Score",
group.col = "Condition",
contrast = c(A = -1, B = 1),
effect.type = "hedges.g",
ci.type = "bca",
ci.conf = 0.95)
results <- data.frame(hedges_g        = round(fit$t0,        3),
hedges_g_se     = round(sd(fit$t),     3),
hedges_g_ci_lwr = round(fit$bounds[1], 3),
hedges_g_ci_upr = round(fit$bounds[2], 3))
}
hedges_g_by_participant <- data %>%
group_by(Participant) %>%
do(hedges_g_boot(data = .)) %>%
ungroup()
# combine results
results <- p_by_participant %>%
left_join(median_change, by = "Participant") %>%
left_join(ruscios_A_boot_by_participant, by = "Participant") %>%
left_join(hedges_g_by_participant, by = "Participant")
return(results)
}
sced_results <- sced_analysis(data = simulated_data)
View(sced_results)
require(tidyverse)
require(metafor)
results <- sced_results
# get data
data_for_meta_analysis <- results %>%
mutate(
yi = ruscios_A,
# convert SE to variance
vi = ruscios_A_se^2
)
results$rucsios_A
