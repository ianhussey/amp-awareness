---
title: "Study 4"
subtitle: "Analyses"
author: "Ian Hussey & Jamie Cummins"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

# To do

1. full sample hasn't been recruited yet
2. check age and party exclusions in the other studies
3. cohen's ds for h6 don't have CIs, probably needs bootstrapping.
4. H2, H3, H4, H6 all need scrutiny, either analyses are off or effects were not replicated/results are not as expected. In the latter case, this seems to run contrary to previous analysis implementations.
4. more to be documented?

# Notes

1. When the DV is binary, we include a predicted probability for the model. This can be a useful addition to R^2.
2. The mixed effects models applied to trial level AMP data are more powerful and are used for hypothesis testing. However, for the sake of familiarity (with the method and similarity to previous published work) we also calculate participant level AMP effect (i.e., sum of positive prime trials rated as positive minus sum of negative prime trials rated as negative) and the analyse these for some central hypotheses, for the sake of familiarity. This could be done for all analyses of AMP data (e.g., manipulation checks), but for brevity's sake we only do it for key hypotheses.
3. We bootstrap estimates and CIs for the key parameters in key hypotheses, to increase robustness. 
4. H2 and H3 from experiment 1 were discarded as being less interesting, but could notionally be assessed in retrospect (i.e., Correlation between online and offline measures of influence, 
Contribution of offline and online measures in predicting AMP effect sizes).

```{r include=FALSE}

knitr::opts_chunk$set(message = FALSE, 
                      warning = FALSE, 
                      cache = TRUE,
                      echo = FALSE)

```

```{r setup, message=FALSE, warning=FALSE, echo=FALSE}

# dependencies
library(tidyverse)
library(lme4)
library(sjPlot)
library(effects)
library(DescTools)
library(Rmisc)
library(effsize)
library(psych)
library(broom)
library(kableExtra)
# devtools::install_github("ianhussey/timesavers")  
library(timesavers)  # for round_df()
library(bootES)

# functions
## Logistic model performance: probability of superiority
ruscios_A <- function(variable, group, data, value1 = 1, value2 = 0) {
  # Ensure data is a data frame (e.g., not a tbl_data)
  data <- as.data.frame(data)
  # Select the observations for group 1
  x <- data[data[[group]] == value1, variable]
  # Select the observations for group 2
  y <- data[data[[group]] == value2, variable]
  # Matrix with difference between XY for all pairs (Guillaume Rousselet's suggestion)
  m <- outer(x, y, FUN = "-")
  # Convert to booleans; count ties as half true.
  m <- ifelse(m == 0, 0.5, m > 0)
  # Return proportion of TRUEs
  ruscios_A <- round(mean(m), 3)
  return(as.numeric(ruscios_A))
}

# # version with CIs - computationally intensive
# ruscios_A_boot <- function(data, variable, group, value1 = 1, value2 = 0, B = 1000) {
#   require(tidyverse)
#   require(broom)
#   ruscios_A_results <- data %>%
#     ruscios_A(variable = variable,
#               group = group,
#               value1 = value1,
#               value2 = value2,
#               data = .)
#   
#   ruscios_A_boot_results <- data %>%
#     broom::bootstrap(B) %>%
#     do(broom::tidy(ruscios_A(variable = variable,
#                              group = group,
#                              value1 = value1,
#                              value2 = value2,
#                              data = .))) %>%
#     ungroup() %>%
#     dplyr::summarize(AUC_ci_lwr = round(quantile(x, 0.025, na.rm = TRUE), 3),
#                      AUC_ci_upr = round(quantile(x, 0.975, na.rm = TRUE), 3)) %>%
#     mutate(AUC_estimate = ruscios_A_results)
#   
#   return(ruscios_A_boot_results)
# }

# get data 
task_level_data <- read.csv("../data/processed/processed_data.csv")

trial_level_politics_ia_amp_data <- read.csv("../data/processed/trial_level_ia_amp_obama_trump_data.csv") %>%
  filter(party %in% c("democrat", "republican")) %>%
  mutate(influenced = dplyr::recode(influenced,
                                    `0` = "no",
                                    `1` = "yes"),
         influenced = as.numeric(influenced))

trial_level_posneg_ia_amp_data <- read.csv("../data/processed/trial_level_ia_amp_positive_negative_data.csv") %>%
  filter(party %in% c("democrat", "republican")) %>%
  mutate(influenced = dplyr::recode(influenced,
                                    `0` = "no",
                                    `1` = "yes"),
         influenced = as.numeric(influenced))


# exclusions
task_level_data_exclusions <- task_level_data %>%
  filter(self_exclusion_1 == "Yes, use my data" & 
           complete_data == TRUE & 
           party %in% c("democrat", "republican") &
           !is.na(age) &
           !is.na(gender) &
           age >= 18 & age <= 65)

trial_level_politics_ia_amp_data_exclusions <- trial_level_politics_ia_amp_data %>%
  filter(self_exclusion_1 == "Yes, use my data" & 
           complete_data == TRUE & 
           party %in% c("democrat", "republican") &
           !is.na(age) &
           !is.na(gender) &
           age >= 18 & age <= 65)

trial_level_posneg_ia_amp_data_exclusions <- trial_level_posneg_ia_amp_data %>%
  filter(self_exclusion_1 == "Yes, use my data" & 
           complete_data == TRUE & 
           party %in% c("democrat", "republican") &
           !is.na(age) &
           !is.na(gender) &
           age >= 18 & age <= 65)

```

# Demographics

Analytic sample after exclusions.

```{r age and gender}

# count by party
task_level_data_exclusions %>%
  dplyr::count(party)
  
# Gender
task_level_data_exclusions %>%
  mutate(gender = tolower(gender)) %>%
  dplyr::count(gender)

# Age mean and SD
task_level_data_exclusions %>%
  mutate(age = as.numeric(as.character(age))) %>%
  dplyr::summarise("age (mean)" = mean(age), 
                   "age (standard deviation)" = sd(age)) %>%
  round_df(2)

```

# Manipulation checks

## M1: Demonstate an AMP effect on the positive negative IA AMP

### Fit model

```{r}

# fit model
model_m1 <- glmer(rating ~ prime_type + (1 | subject), 
                  family = binomial(link = "logit"),
                  data = trial_level_posneg_ia_amp_data_exclusions)

# plot
plot_model(model_m1, type = "pred", terms = c("prime_type"))

# results table
tab_model(model_m1, emph.p = FALSE, ci.hyphen = ", ")

```

### Bootstrap estimates for key parameters

```{r}

# bootstrap estimates and CIs for key parameters
# apply fixef() to the output of each boot to get fixed effects, save only this to the data frame
model_m1_boot <- bootMer(model_m1, 
                         FUN = fixef,  
                         nsim = 1000,
                         parallel = "multicore")

# write to disk given long runtime
save(model_m1_boot, file = "data/models/model_m1_boot.RData")
load("data/models/model_m1_boot.RData")

# print results
model_m1_boot %>%
  as.data.frame() %>%
  # exponentiate to convert log odds to odds
  summarize(prime_type_OR_median = quantile(exp(prime_type), 0.500, na.rm = TRUE),  
            prime_type_OR_lwr    = quantile(exp(prime_type), 0.025, na.rm = TRUE),
            prime_type_OR_upr    = quantile(exp(prime_type), 0.975, na.rm = TRUE)) %>%
  round_df(2) %>%
  gather()

```

### Model performance

```{r}

# add model predictions back to the original data frame
trial_level_posneg_ia_amp_data_exclusions$m1_predicted_probability <- 
  predict(model_m1, type = "response")

# predicted probability
m1_pp <- ruscios_A(data = trial_level_posneg_ia_amp_data_exclusions, 
                   variable = "m1_predicted_probability", 
                   group = "rating")

```

Model predicted probability = `r m1_pp`. In this case this is the probability that a randomly selected trial preceeded by a positive prime was evaluated more positively than a randomly selected negative prime.

# Hypothesis tests

## H1: Politics IA-AMP influence rate predicts politics IA-AMP effect

### H1a: at the trial level

Does conscious awareness of influence of the prime on the target moderate the AMP effect?

Key effect: influence*prime_type interaction

#### Fit model

```{r}

# model
model_h1a <- glmer(rating ~ influenced * prime_type + (1 | subject), 
                   family = binomial(link = "logit"),
                   data = trial_level_politics_ia_amp_data_exclusions)

# plot
plot_model(model_h1a, type = "pred", terms = c("influenced", "prime_type"))

# results table
tab_model(model_h1a, emph.p = FALSE, ci.hyphen = ", ")

```

#### Bootstrap estimates for key parameters

```{r}

# apply fixef() to the output of each boot to get fixed effects, save only this to the data frame
model_h1a_boot <- bootMer(model_h1a, 
                          FUN = fixef,  
                          nsim = 1000,
                          parallel = "multicore")

# write to disk given long runtime
save(model_h1a_boot, file = "data/models/model_h1a_boot.RData")
load("data/models/model_h1a_boot.RData")

# print results
model_h1a_boot %>%
  as.data.frame() %>%
  summarize(prime_type_OR_median = quantile(exp(influenced:prime_type), 0.500, na.rm = TRUE),  # exponentiate to convert log odds to odds ratios
            prime_type_OR_lwr    = quantile(exp(influenced:prime_type), 0.025, na.rm = TRUE),
            prime_type_OR_upr    = quantile(exp(influenced:prime_type), 0.975, na.rm = TRUE)) %>%
  round_df(2) %>%
  gather()

```

#### Model performance

```{r}

# add model predictions back to the original data frame
trial_level_politics_ia_amp_data_exclusions$h1a_predicted_probability <- 
  predict(model_h1a, type = "response")

# predicted probability
h1a_pp <- ruscios_A(data = trial_level_politics_ia_amp_data_exclusions, 
                    variable = "h1a_predicted_probability", 
                    group = "rating") 

```

Model predicted probability = `r h1a_pp`.

### H1b: at the participant level

Does rate of influence in the IA-AMP predict IA-AMP effects?

If effects in the IA-AMP are driven by intentional responding, then the size of the effect in the IA-AMP should be moderated by the subset of participants who are more often influenced by the primes. 
#### Fit model

```{r}

# model
fit_h1b <- lm(abs(IA_AMP_effect_obama_trump) ~ influence_rate_obama_trump, 
              data = task_level_data_exclusions)

# plot
ggplot(task_level_data_exclusions, aes(influence_rate_obama_trump, 
                                       abs(IA_AMP_effect_obama_trump))) + 
  geom_jitter(alpha = 0.3) +
  geom_rug(position = "jitter") +
  geom_smooth(method = lm) +
  labs(title = "Proportion of influenced trials and politics IA-AMP effect", 
       x = "Proportion of influenced trials\non the politics IA-AMP", 
       y = "Absolute politics IA-AMP effect") +
  theme_classic()

# results table
tab_model(fit_h1b, emph.p = FALSE, ci.hyphen = ", ")

```

## H2: Politics IA-AMP influence rate predicts politics IA-AMP effect

### H2a: at the trial level

Does conscious awareness of influence of the prime on the target moderate the AMP effect?

Key effect: influence*prime_type interaction

#### Fit model

```{r}

# model
model_h2a <- glmer(rating ~ influenced * prime_type + (1 | subject), 
                   family = binomial(link = "logit"),
                   data = trial_level_posneg_ia_amp_data_exclusions)

# plot
plot_model(model_h2a, type = "pred", terms = c("influenced", "prime_type"))

# results table
tab_model(model_h2a, emph.p = FALSE, ci.hyphen = ", ")

```

#### Bootstrap estimates for key parameters

```{r}

# apply fixef() to the output of each boot to get fixed effects, save only this to the data frame
model_h2a_boot <- bootMer(model_h2a, 
                          FUN = fixef,  
                          nsim = 1000,
                          parallel = "multicore")

# write to disk given long runtime
save(model_h2a_boot, file = "data/models/model_h2a_boot.RData")
load("data/models/model_h2a_boot.RData")

# print results
model_h2a_boot %>%
  as.data.frame() %>%
  summarize(prime_type_OR_median = quantile(exp(influenced:prime_type), 0.500, na.rm = TRUE),  # exponentiate to convert log odds to odds ratios
            prime_type_OR_lwr    = quantile(exp(influenced:prime_type), 0.025, na.rm = TRUE),
            prime_type_OR_upr    = quantile(exp(influenced:prime_type), 0.975, na.rm = TRUE)) %>%
  round_df(2) %>%
  gather()

```

#### Model performance

```{r}

# add model predictions back to the original data frame
trial_level_posneg_ia_amp_data_exclusions$h2a_predicted_probability <- 
  predict(model_h2a, type = "response")

# predicted probability
h2a_pp <- ruscios_A(data = trial_level_posneg_ia_amp_data_exclusions, 
                    variable = "h2a_predicted_probability", 
                    group = "rating") 

```

Model predicted probability = `r h2a_pp`.

### H2b: at the participant level

Does rate of influence in the IA-AMP predict IA-AMP effects?

If effects in the IA-AMP are driven by intentional responding, then the size of the effect in the IA-AMP should be moderated by the subset of participants who are more often influenced by the primes. 
#### Fit model

```{r}

# model
fit_h2b <- lm(IA_AMP_effect_positive_negative ~ influence_rate_positive_negative, 
              data = task_level_data_exclusions)

# plot
ggplot(task_level_data_exclusions, aes(influence_rate_positive_negative, 
                                       IA_AMP_effect_positive_negative)) + 
  geom_jitter(alpha = 0.3) +
  geom_rug(position = "jitter") +
  geom_smooth(method = lm) +
  labs(title = "Proportion of influenced trials and positive-negative IA-AMP effect", 
       x = "Proportion of influenced trials\non the positive-negative IA-AMP", 
       y = "Positive-negative IA-AMP effect") +
  theme_classic()

# results table
tab_model(fit_h1b, emph.p = FALSE, ci.hyphen = ", ")

```

## H3: Positive-negative IA-AMP influence rate predicts the absolute magnitude of the politics IA-AMP effect

If effects in the AMPs are driven by participants who are more often influenced, then rate of influence in one IA-AMP should predict effect sizes in the other. 

Because the politics AMP is completed prior to the positive-negative IA AMP, if the positive-negative IA AMP's influence rate predicts the (previously completed) politics IA-AMP's effect then this implies that the rate of influence is reliable within participants/across IA AMPs.

```{r}

# model
fit_h3 <- lm(abs(IA_AMP_effect_obama_trump) ~ influence_rate_positive_negative, 
             data = task_level_data_exclusions)

# plot
ggplot(task_level_data_exclusions, aes(influence_rate_positive_negative, 
                                       abs(IA_AMP_effect_obama_trump))) + 
  geom_jitter(alpha = 0.3) +
  geom_rug(position = "jitter") +
  geom_smooth(method = lm) +
  labs(title = "Rate of influence in the positive-negative IA-AMP and politics IA-AMP effect size", 
       x = "Positive-negative IA-AMP influence rate", 
       y = "Politics IA-AMP effect size") +
  theme_classic()

# table
tab_model(fit_h3, emph.p = FALSE, ci.hyphen = ", ")

```

### Bootstrap estimates

*To be added*

## H4: Politics IA-AMP influence rate predicts the absolute magnitude of the positive-negative IA-AMP effect

```{r}

# model
fit_h4 <- lm(abs(IA_AMP_effect_positive_negative) ~ influence_rate_obama_trump, 
             data = task_level_data_exclusions)

# plot
ggplot(task_level_data_exclusions, aes(influence_rate_obama_trump, 
                                       abs(IA_AMP_effect_positive_negative))) + 
  geom_jitter(alpha = 0.3) +
  geom_rug(position = "jitter") +
  geom_smooth(method = lm) +
  labs(title = "Rate of influence in the politics IA-AMP and positive-negative IA-AMP effect size", 
       x = "Politics IA-AMP influence rate", 
       y = "Positive-negative IA-AMP effect size") +
  theme_classic()

# table
tab_model(fit_h4, emph.p = FALSE, ci.hyphen = ", ")

```

### Bootstrap estimates

*To be added*

## H5: Influence rates correlate between IA-AMPs across different domains

If the subset of participants who respond intentionally in the AMP are consistent across procedures, then then influence rates in the AMP should correlate.

Bootstrapped estimate for robustness.

```{r fig.height=6, fig.width=6}

# test 
cor.test(task_level_data_exclusions$influence_rate_obama_trump,
         task_level_data_exclusions$influence_rate_positive_negative,
         paired = TRUE) %>% 
  tidy()

# bootstrap estimates
task_level_data_exclusions %>%
  broom::bootstrap(2000) %>%
  do(r = cor.test(.$influence_rate_obama_trump,
                  .$influence_rate_positive_negative,
                  paired = TRUE)$estimate) %>%
  ungroup() %>%
  mutate(r = as.numeric(r)) %>%
  dplyr::summarize(r_median = round(quantile(r, 0.500, na.rm = TRUE), 3),
                   r_ci_lwr = round(quantile(r, 0.025, na.rm = TRUE), 3),
                   r_ci_upr = round(quantile(r, 0.975, na.rm = TRUE), 3))

# plot
ggplot(task_level_data_exclusions, 
       aes(influence_rate_obama_trump, influence_rate_positive_negative)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(x = "Influence rate in\npolitics IA-AMP", y = "Influence rate in\npositive-negative IA-AMP") +
  theme_classic() +
  ylim(0,1) +
  xlim(0,1)

# ggplot(task_level_data_exclusions, 
#        aes(influence_rate_obama_trump)) +
#   geom_density()
# 
# ggplot(task_level_data_exclusions, 
#        aes(influence_rate_positive_negative)) +
#   geom_density()

```

## H6: The politics IA-AMPs ability to predict political affiliation is driven by the subset of trials on which participants reporting being influenced

### Group membership predicting AMP effect from influenced trials

```{r}

# test
t.test(IA_AMP_effect_obama_trump_influenced ~ party,
       family = binomial,
       data = task_level_data_exclusions)

# Cohen's d
# effsize::cohen.d(IA_AMP_effect_obama_trump_influenced ~ party,
#                  family = binomial,
#                  data = task_level_data_exclusions)

fit_influenced <- task_level_data_exclusions %>%
  bootES(.,
         R = 2000,
         data.col = "IA_AMP_effect_obama_trump_influenced",
         group.col = "party",
         contrast = c(A = "republican", B = "democrat"),
         effect.type = "cohens.d",
         ci.type = "bca",
         ci.conf = 0.95)

data.frame(cohens_d = round(fit_influenced$t0,        2),
           se       = round(sd(fit_influenced$t),     2),
           ci_lwr   = round(fit_influenced$bounds[1], 2),
           ci_upr   = round(fit_influenced$bounds[2], 2))

```

### Group membership predicting AMP effect from uninfluenced trials

```{r}

# test
t.test(IA_AMP_effect_obama_trump_uninfluenced ~ party,
       family = binomial,
       data = task_level_data_exclusions)

# Cohen's d
# effsize::cohen.d(IA_AMP_effect_obama_trump_uninfluenced ~ party,
#                  family = binomial,
#                  data = task_level_data_exclusions)

fit_uninfluenced <- task_level_data_exclusions %>%
  bootES(.,
         R = 2000,
         data.col = "IA_AMP_effect_obama_trump_uninfluenced",
         group.col = "party",
         contrast = c(A = "republican", B = "democrat"),
         effect.type = "cohens.d",
         ci.type = "bca",
         ci.conf = 0.95)

data.frame(cohens_d = round(fit_uninfluenced$t0,        2),
           se       = round(sd(fit_uninfluenced$t),     2),
           ci_lwr   = round(fit_uninfluenced$bounds[1], 2),
           ci_upr   = round(fit_uninfluenced$bounds[2], 2))

```
