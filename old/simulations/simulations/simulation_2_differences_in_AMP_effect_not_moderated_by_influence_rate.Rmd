---
title: "Predictive ability of the AMP"
subtitle: "Simulation 2: Differences in AMP effect not moderated by influence rate"
author: "Ian Hussey & Jamie Cummins"
output:
  html_document:
    code_folding: hide
    highlight: haddock
    number_sections: no
    theme: flatly
    toc: yes
    toc_float: yes
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      cache.lazy = FALSE)
```

```{r}

# dependencies
library(tidyverse)
library(psych)
library(knitr)
library(sjPlot)
library(broom)
library(kableExtra)
library(timesavers)
library(patchwork)

# plot function
source("geom_flat_violin.R")

# disable scientific notation
options(scipen = 999) 

# comment out if knitting to pdf
options(knitr.table.format = "html")

# get data
#input_data <- read.csv("../simulated_data/simulation_1_differences_in_AMP_effect_moderated_by_influence_rate.csv")
input_data <- read.csv("../simulated_data/simulation_2_differences_in_AMP_effect_not_moderated_by_influence_rate.csv")
#input_data <- read.csv("../simulated_data/simulation_3_no_differences_in_AMP_effect_not_moderated_by_influence_rate.csv")

```

# plot raw data

```{r}

# distribution of simulated data
ggplot(input_data, aes(influence_rate, std_amp_effect, color = as.factor(group))) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm") +
  scale_colour_viridis_d(end = .6) +
  theme_classic() +
  xlim(0,1) +
  ylim(-1,1)

# impact of influence on amp effects
ggplot(input_data, aes(x = as.factor(group), y = std_amp_effect, color = influence_rate)) + 
  geom_jitter(alpha = 0.4, width = .05, height = 0.05) + 
  theme_classic() +
  scale_colour_viridis_c() +
  ylim(-1,1)

```

# Model 1 - AMP effect predicts group membership

Binomial logistic regression: group ~ predictor

```{r}

# model
model_1 <- glm(group ~ std_amp_effect, 
               family = binomial(link="logit"), 
               data = input_data)

# Assess model fit

## extraction predicted probabilities
prob <- predict(model_1, type = c("response"), se.fit = TRUE)

## add these probabilities back to the original data frame (omitting missing values) 
predictions <- input_data %>%
  select(group) %>%
  na.omit %>%
  mutate(prob = prob$fit)


## proportion of correct ordinal rankings/probability of a randomly chosen member of one group having a higher predicted probability than the other group
ruscios_A_results <- ruscios_A_boot(data = predictions, variable = "prob", group = "group")

ruscios_A_string <- paste0("AMP effect prediction of group membership: Ruscio's A = ", ruscios_A_results$ruscios_A, ", 95% CI [", ruscios_A_results$ruscios_A_ci_lwr, ", ", ruscios_A_results$ruscios_A_ci_upr, "]")


# plot
p1 <- 
  ggplot(data = predictions, 
         aes(x = as.factor(group), 
             y = prob, 
             fill = as.factor(group))) +
  geom_flat_violin(position = position_nudge(x = .2, y = 0), 
                   alpha = .8) +
  geom_point(aes(y = prob, 
                 color = as.factor(group)), 
             position = position_jitter(width = .15), 
             size = .5, 
             alpha = 0.5) +
  guides(fill = FALSE) +
  guides(color = FALSE) +
  scale_colour_viridis_d(end = 0.6) +
  scale_fill_viridis_d(end = 0.6) +
  coord_flip() +
  theme_classic() +
  xlab("Group") +
  ylab("Predicted probability") +
  ggtitle("AMP") +
  ylim(0,1)

```

# Model 2 - first partial out influence rate, then examine whether AMP effect predicts group membership

```{r}

# partial out influence from amp effect

# Create an 'inverted' column which specifies the direction of the AMP effect (positive or negative), and also create an absolute AMP effect column
temp_data <- input_data %>%
  mutate(inverted = ifelse(std_amp_effect < 0, TRUE, FALSE),
         abs_std_amp_effect = abs(std_amp_effect))

# fit model to partial out influence from absolute amp effect
model_2a <- lm(abs_std_amp_effect ~ influence_rate, 
               data = temp_data)

# extract residuals
residuals_temp <- augment(model_2a)

# add residuals to full data, then uninvert the AMP scores back to native directions
data_with_residuals <- temp_data %>%
  mutate(std_amp_effect_minus_influence_rate = residuals_temp$.resid,
         std_amp_effect_minus_influence_rate_uninverted = ifelse(inverted == TRUE, 1 - std_amp_effect_minus_influence_rate, std_amp_effect_minus_influence_rate))

# fit new prediction model
model_2b <- glm(group ~ std_amp_effect_minus_influence_rate_uninverted, 
                family = binomial(link="logit"), 
                data = data_with_residuals)


# Assess model fit

## extract predicted probabilities
prob2 <- predict(model_2b, type = c("response"), se.fit = TRUE)

## add these probabilities back to the original data frame (omitting missing values) 
predictions2 <- input_data %>%
  select(group) %>%
  na.omit %>%
  mutate(prob = prob2$fit)

## proportion of correct ordinal rankings/probability of a randomly chosen member of one group having a higher predicted probability than the other group
ruscios_A_results_2 <- ruscios_A_boot(data = predictions2, variable = "prob", group = "group")

ruscios_A_string_2 <- paste0("AMP effect prediction of group membership after partialing out influence rate: Ruscio's A = ", ruscios_A_results_2$ruscios_A, ", 95% CI [", ruscios_A_results_2$ruscios_A_ci_lwr, ", ", ruscios_A_results_2$ruscios_A_ci_upr, "]")

## plot
p2 <- 
  ggplot(data = predictions2, 
         aes(x = as.factor(group), 
             y = prob, 
             fill = as.factor(group))) +
  geom_flat_violin(position = position_nudge(x = .2, y = 0), 
                   alpha = .8) +
  geom_point(aes(y = prob, 
                 color = as.factor(group)), 
             position = position_jitter(width = .15), 
             size = .5, 
             alpha = 0.5) +
  guides(fill = FALSE) +
  guides(color = FALSE) +
  scale_colour_viridis_d(end = 0.6) +
  scale_fill_viridis_d(end = 0.6) +
  coord_flip() +
  theme_classic() +
  xlab("Group") +
  ylab("Predicted probability") +
  ggtitle("AMP - intentionality") +
  ylim(0,1)

```

# Compare predictions made by the two models

```{r fig.height=7, fig.width=7}

p1 + p2 + plot_layout(ncol = 1)

```

`r ruscios_A_string`

`r ruscios_A_string_2`

# Plot residuals

```{r}

ggplot(data = data_with_residuals, 
         aes(x = as.factor(group), 
             y = std_amp_effect_minus_influence_rate_uninverted, 
             fill = as.factor(group))) +
  geom_flat_violin(position = position_nudge(x = .2, y = 0), 
                   alpha = .8) +
  geom_point(aes(y = std_amp_effect_minus_influence_rate_uninverted, 
                 color = as.factor(group)), 
             position = position_jitter(width = .15), 
             size = .5, 
             alpha = 0.5) +
  guides(fill = FALSE) +
  guides(color = FALSE) +
  scale_colour_viridis_d(end = 0.6) +
  scale_fill_viridis_d(end = 0.6) +
  coord_flip() +
  theme_classic() +
  xlab("Group") +
  ylab("std_amp_effect_minus_influence_rate_uninverted")

```

# Alt analysis

```{r}

## AMP effects

library(effsize)
library(timesavers)

es <- effsize::cohen.d(std_amp_effect ~ group, 
                       data = input_data)

es_ord <- ruscios_A_boot(variable = "std_amp_effect", 
                         group = "group",
                         data = input_data)

AMP_effect_group_differences <- 
  data.frame(data = "AMP effect",
             cohens_d = es$estimate,
             cohens_d_ci_lwr = es$conf.int[1],
             cohens_d_ci_upr = es$conf.int[2],
             ruscios_A = es_ord$ruscios_A,
             ruscios_A_ci_lwr = es_ord$ruscios_A_ci_lwr,
             ruscios_A_ci_upr = es_ord$ruscios_A_ci_upr) %>%
  round_df(2) 



## AMP effects after controlling for influence rate

es_2 <- effsize::cohen.d(std_amp_effect_minus_influence_rate_uninverted ~ group, 
                         data = data_with_residuals)

# ruscios_A_results_2 already calculated above

AMP_effect_minus_influence_group_differences <- 
  data.frame(data = "AMP effect minus influence",
             cohens_d = es_2$estimate,
             cohens_d_ci_lwr = es_2$conf.int[1],
             cohens_d_ci_upr = es_2$conf.int[2],
             ruscios_A = ruscios_A_results_2$ruscios_A,
             ruscios_A_ci_lwr = ruscios_A_results_2$ruscios_A_ci_lwr,
             ruscios_A_ci_upr = ruscios_A_results_2$ruscios_A_ci_upr) %>%
  round_df(2)

combined <- rbind(AMP_effect_group_differences, AMP_effect_minus_influence_group_differences)

rownames(combined) <- NULL

combined %>% kable()

```

